{"ast":null,"code":"import { Contract, ethers } from \"ethers\";\nimport { fetchReserves, getDecimals } from \"../ethereumFunctions\";\n\nconst ERC20 = require(\"../build/ERC20.json\");\n\nconst PAIR = require(\"../build/IUniswapV2Pair.json\"); // Function used to add Liquidity to any pair of tokens or token-AUT\n// To work correctly, there needs to be 9 arguments:\n//    `address1` - An Ethereum address of the coin to add from (either a token or AUT)\n//    `address2` - An Ethereum address of the coin to add to (either a token or AUT)\n//    `amount1` - A float or similar number representing the value of address1's coin to add\n//    `amount2` - A float or similar number representing the value of address2's coin to add\n//    `amount1Min` - A float or similar number representing the minimum of address1's coin to add\n//    `amount2Min` - A float or similar number representing the minimum of address2's coin to add\n//    `routerContract` - The router contract to carry out this trade\n//    `accountAddress` - An Ethereum address of the current user's account\n//    `provider` - The current provider\n//    `signer` - The current signer\n\n\nexport async function addLiquidity(address1, address2, amount1, amount2, amount1min, amount2min, routerContract, account, signer) {\n  const token1 = new Contract(address1, ERC20.abi, signer);\n  const token2 = new Contract(address2, ERC20.abi, signer);\n  const token1Decimals = await getDecimals(token1);\n  const token2Decimals = await getDecimals(token2);\n  const amountIn1 = ethers.utils.parseUnits(amount1, token1Decimals);\n  const amountIn2 = ethers.utils.parseUnits(amount2, token2Decimals);\n  const amount1Min = ethers.utils.parseUnits(amount1min, token1Decimals);\n  const amount2Min = ethers.utils.parseUnits(amount2min, token2Decimals);\n  const time = Math.floor(Date.now() / 1000) + 200000;\n  const deadline = ethers.BigNumber.from(time);\n  await token1.approve(routerContract.address, amountIn1);\n  await token2.approve(routerContract.address, amountIn2);\n  const wethAddress = await routerContract.WETH();\n  console.log([address1, address2, amountIn1, amountIn2, amount1Min, amount2Min, account, deadline]);\n\n  if (address1 === wethAddress) {\n    // Eth + Token\n    await routerContract.addLiquidityETH(address2, amountIn2, amount2Min, amount1Min, account, deadline, {\n      value: amountIn1\n    });\n  } else if (address2 === wethAddress) {\n    // Token + Eth\n    await routerContract.addLiquidityETH(address1, amountIn1, amount1Min, amount2Min, account, deadline, {\n      value: amountIn2\n    });\n  } else {\n    // Token + Token\n    await routerContract.addLiquidity(address1, address2, amountIn1, amountIn2, amount1Min, amount2Min, account, deadline);\n  }\n} // Function used to remove Liquidity from any pair of tokens or token-AUT\n// To work correctly, there needs to be 9 arguments:\n//    `address1` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `address2` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `liquidity_tokens` - A float or similar number representing the value of liquidity tokens you will burn to get tokens back\n//    `amount1Min` - A float or similar number representing the minimum of address1's coin to recieve\n//    `amount2Min` - A float or similar number representing the minimum of address2's coin to recieve\n//    `routerContract` - The router contract to carry out this trade\n//    `accountAddress` - An Ethereum address of the current user's account\n//    `provider` - The current provider\n//    `signer` - The current signer\n\nexport async function removeLiquidity(address1, address2, liquidity_tokens, amount1min, amount2min, routerContract, account, signer, factory) {\n  const token1 = new Contract(address1, ERC20.abi, signer);\n  const token2 = new Contract(address2, ERC20.abi, signer);\n  const token1Decimals = await getDecimals(token1);\n  const token2Decimals = await getDecimals(token2);\n\n  const Getliquidity = liquidity_tokens => {\n    if (liquidity_tokens < 0.001) {\n      return ethers.BigNumber.from(liquidity_tokens * 10 ** 18);\n    }\n\n    return ethers.utils.parseUnits(String(liquidity_tokens), 18);\n  };\n\n  const liquidity = Getliquidity(liquidity_tokens);\n  console.log('liquidity: ', liquidity);\n  const amount1Min = ethers.utils.parseUnits(String(amount1min), token1Decimals);\n  const amount2Min = ethers.utils.parseUnits(String(amount2min), token2Decimals);\n  const time = Math.floor(Date.now() / 1000) + 200000;\n  const deadline = ethers.BigNumber.from(time);\n  const wethAddress = await routerContract.WETH();\n  const pairAddress = await factory.getPair(address1, address2);\n  const pair = new Contract(pairAddress, PAIR.abi, signer);\n  await pair.approve(routerContract.address, liquidity);\n  console.log([address1, address2, Number(liquidity), Number(amount1Min), Number(amount2Min), account, deadline]);\n\n  if (address1 === wethAddress) {\n    // Eth + Token\n    await routerContract.removeLiquidityETH(address2, liquidity, amount2Min, amount1Min, account, deadline);\n  } else if (address2 === wethAddress) {\n    // Token + Eth\n    await routerContract.removeLiquidityETH(address1, liquidity, amount1Min, amount2Min, account, deadline);\n  } else {\n    // Token + Token\n    await routerContract.removeLiquidity(address1, address2, liquidity, amount1Min, amount2Min, account, deadline);\n  }\n}\n\nconst quote = (amount1, reserve1, reserve2) => {\n  const amount2 = amount1 * (reserve2 / reserve1);\n  return [amount2];\n}; // Function used to get a quote of the liquidity addition\n//    `address1` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `address2` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `amountA_desired` - The prefered value of the first token that the user would like to deploy as liquidity\n//    `amountB_desired` - The prefered value of the second token that the user would like to deploy as liquidity\n//    `factory` - The current factory\n//    `signer` - The current signer\n\n\nasync function quoteMintLiquidity(address1, address2, amountA, amountB, factory, signer) {\n  const MINIMUM_LIQUIDITY = 1000;\n  let _reserveA = 0;\n  let _reserveB = 0;\n  let totalSupply = 0;\n  [_reserveA, _reserveB, totalSupply] = await factory.getPair(address1, address2).then(async pairAddress => {\n    if (pairAddress !== '0x0000000000000000000000000000000000000000') {\n      const pair = new Contract(pairAddress, PAIR.abi, signer);\n      const reservesRaw = await fetchReserves(address1, address2, pair, signer); // Returns the reserves already formated as ethers\n\n      const reserveA = reservesRaw[0];\n      const reserveB = reservesRaw[1];\n\n      const _totalSupply = await pair.totalSupply();\n\n      const totalSupply = Number(ethers.utils.formatEther(_totalSupply));\n      return [reserveA, reserveB, totalSupply];\n    } else {\n      return [0, 0, 0];\n    }\n  });\n  const token1 = new Contract(address1, ERC20.abi, signer);\n  const token2 = new Contract(address2, ERC20.abi, signer); // Need to do all this decimals work to account for 0 decimal numbers\n\n  const token1Decimals = await getDecimals(token1);\n  const token2Decimals = await getDecimals(token2);\n  const valueA = amountA * 10 ** token1Decimals;\n  const valueB = amountB * 10 ** token2Decimals;\n  const reserveA = _reserveA * 10 ** token1Decimals;\n  const reserveB = _reserveB * 10 ** token2Decimals;\n\n  if (totalSupply == 0) {\n    return Math.sqrt(valueA * valueB - MINIMUM_LIQUIDITY) * 10 ** -18;\n  }\n\n  ;\n  return Math.min(valueA * totalSupply / reserveA, valueB * totalSupply / reserveB);\n}\n\n;\nexport async function quoteAddLiquidity(address1, address2, amountADesired, amountBDesired, factory, signer) {\n  const pairAddress = await factory.getPair(address1, address2);\n  const pair = new Contract(pairAddress, PAIR.abi, signer);\n  const reservesRaw = await fetchReserves(address1, address2, pair, signer); // Returns the reserves already formated as ethers\n\n  const reserveA = reservesRaw[0];\n  const reserveB = reservesRaw[1];\n\n  if (reserveA === 0 && reserveB === 0) {\n    const amountOut = await quoteMintLiquidity(address1, address2, amountADesired, amountBDesired, factory, signer);\n    return [amountADesired, amountBDesired, amountOut.toPrecision(8)];\n  } else {\n    const amountBOptimal = quote(amountADesired, reserveA, reserveB);\n\n    if (amountBOptimal <= amountBDesired) {\n      const amountOut = await quoteMintLiquidity(address1, address2, amountADesired, amountBOptimal, factory, signer);\n      return [amountADesired, amountBOptimal, amountOut.toPrecision(8)];\n    } else {\n      const amountAOptimal = quote(amountBDesired, reserveB, reserveA);\n      const amountOut = await quoteMintLiquidity(address1, address2, amountAOptimal, amountBDesired, factory, signer);\n      return [amountAOptimal, amountBDesired, amountOut.toPrecision(8)];\n    }\n  }\n} // Function used to get a quote of the liquidity removal\n//    `address1` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `address2` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `liquidity` - The amount of liquidity tokens the user will burn to get their tokens back\n//    `factory` - The current factory\n//    `signer` - The current signer\n\nexport async function quoteRemoveLiquidity(address1, address2, liquidity, factory, signer) {\n  const pairAddress = await factory.getPair(address1, address2);\n  console.log(\"pair address\", pairAddress);\n  const pair = new Contract(pairAddress, PAIR.abi, signer);\n  const reservesRaw = await fetchReserves(address1, address2, pair, signer); // Returns the reserves already formated as ethers\n\n  const reserveA = reservesRaw[0];\n  const reserveB = reservesRaw[1];\n  const feeOn = (await factory.feeTo()) !== 0x0000000000000000000000000000000000000000;\n\n  const _kLast = await pair.kLast();\n\n  const kLast = Number(ethers.utils.formatEther(_kLast));\n\n  const _totalSupply = await pair.totalSupply();\n\n  let totalSupply = Number(ethers.utils.formatEther(_totalSupply));\n\n  if (feeOn && kLast > 0) {\n    const feeLiquidity = totalSupply * (Math.sqrt(reserveA * reserveB) - Math.sqrt(kLast)) / (5 * Math.sqrt(reserveA * reserveB) + Math.sqrt(kLast));\n    totalSupply = totalSupply + feeLiquidity;\n  }\n\n  const Aout = reserveA * liquidity / totalSupply;\n  const Bout = reserveB * liquidity / totalSupply;\n  return [liquidity, Aout, Bout];\n}","map":{"version":3,"sources":["/Users/lelouch/Desktop/ethnyc/eth-nyc-global/uni/src/Liquidity/LiquidityFunctions.js"],"names":["Contract","ethers","fetchReserves","getDecimals","ERC20","require","PAIR","addLiquidity","address1","address2","amount1","amount2","amount1min","amount2min","routerContract","account","signer","token1","abi","token2","token1Decimals","token2Decimals","amountIn1","utils","parseUnits","amountIn2","amount1Min","amount2Min","time","Math","floor","Date","now","deadline","BigNumber","from","approve","address","wethAddress","WETH","console","log","addLiquidityETH","value","removeLiquidity","liquidity_tokens","factory","Getliquidity","String","liquidity","pairAddress","getPair","pair","Number","removeLiquidityETH","quote","reserve1","reserve2","quoteMintLiquidity","amountA","amountB","MINIMUM_LIQUIDITY","_reserveA","_reserveB","totalSupply","then","reservesRaw","reserveA","reserveB","_totalSupply","formatEther","valueA","valueB","sqrt","min","quoteAddLiquidity","amountADesired","amountBDesired","amountOut","toPrecision","amountBOptimal","amountAOptimal","quoteRemoveLiquidity","feeOn","feeTo","_kLast","kLast","feeLiquidity","Aout","Bout"],"mappings":"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","sourcesContent":["import { Contract, ethers } from \"ethers\";\nimport { fetchReserves, getDecimals } from \"../ethereumFunctions\";\n\nconst ERC20 = require(\"../build/ERC20.json\");\nconst PAIR = require(\"../build/IUniswapV2Pair.json\");\n\n// Function used to add Liquidity to any pair of tokens or token-AUT\n// To work correctly, there needs to be 9 arguments:\n//    `address1` - An Ethereum address of the coin to add from (either a token or AUT)\n//    `address2` - An Ethereum address of the coin to add to (either a token or AUT)\n//    `amount1` - A float or similar number representing the value of address1's coin to add\n//    `amount2` - A float or similar number representing the value of address2's coin to add\n//    `amount1Min` - A float or similar number representing the minimum of address1's coin to add\n//    `amount2Min` - A float or similar number representing the minimum of address2's coin to add\n//    `routerContract` - The router contract to carry out this trade\n//    `accountAddress` - An Ethereum address of the current user's account\n//    `provider` - The current provider\n//    `signer` - The current signer\nexport async function addLiquidity(\n  address1,\n  address2,\n  amount1,\n  amount2,\n  amount1min,\n  amount2min,\n  routerContract,\n  account,\n  signer\n) {\n  const token1 = new Contract(address1, ERC20.abi, signer);\n  const token2 = new Contract(address2, ERC20.abi, signer);\n\n  const token1Decimals = await getDecimals(token1);\n  const token2Decimals = await getDecimals(token2);\n\n  const amountIn1 = ethers.utils.parseUnits(amount1, token1Decimals);\n  const amountIn2 = ethers.utils.parseUnits(amount2, token2Decimals);\n\n  const amount1Min = ethers.utils.parseUnits(amount1min, token1Decimals);\n  const amount2Min = ethers.utils.parseUnits(amount2min, token2Decimals);\n\n  const time = Math.floor(Date.now() / 1000) + 200000;\n  const deadline = ethers.BigNumber.from(time);\n\n  await token1.approve(routerContract.address, amountIn1);\n  await token2.approve(routerContract.address, amountIn2);\n\n  const wethAddress = await routerContract.WETH();\n\n  console.log([\n    address1,\n    address2,\n    amountIn1,\n    amountIn2,\n    amount1Min,\n    amount2Min,\n    account,\n    deadline,\n  ]);\n\n  if (address1 === wethAddress) {\n    // Eth + Token\n    await routerContract.addLiquidityETH(\n      address2,\n      amountIn2,\n      amount2Min,\n      amount1Min,\n      account,\n      deadline,\n      { value: amountIn1 }\n    );\n  } else if (address2 === wethAddress) {\n    // Token + Eth\n    await routerContract.addLiquidityETH(\n      address1,\n      amountIn1,\n      amount1Min,\n      amount2Min,\n      account,\n      deadline,\n      { value: amountIn2 }\n    );\n  } else {\n    // Token + Token\n    await routerContract.addLiquidity(\n      address1,\n      address2,\n      amountIn1,\n      amountIn2,\n      amount1Min,\n      amount2Min,\n      account,\n      deadline\n    );\n  }\n}\n\n// Function used to remove Liquidity from any pair of tokens or token-AUT\n// To work correctly, there needs to be 9 arguments:\n//    `address1` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `address2` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `liquidity_tokens` - A float or similar number representing the value of liquidity tokens you will burn to get tokens back\n//    `amount1Min` - A float or similar number representing the minimum of address1's coin to recieve\n//    `amount2Min` - A float or similar number representing the minimum of address2's coin to recieve\n//    `routerContract` - The router contract to carry out this trade\n//    `accountAddress` - An Ethereum address of the current user's account\n//    `provider` - The current provider\n//    `signer` - The current signer\nexport async function removeLiquidity(\n  address1,\n  address2,\n  liquidity_tokens,\n  amount1min,\n  amount2min,\n  routerContract,\n  account,\n  signer,\n  factory\n) {\n  const token1 = new Contract(address1, ERC20.abi, signer);\n  const token2 = new Contract(address2, ERC20.abi, signer);\n\n  const token1Decimals = await getDecimals(token1);\n  const token2Decimals = await getDecimals(token2);\n\n  const Getliquidity = (liquidity_tokens)=>{\n    if (liquidity_tokens < 0.001){\n      return ethers.BigNumber.from(liquidity_tokens*10**18);\n    }\n    return ethers.utils.parseUnits(String(liquidity_tokens), 18);\n  }\n\n  const liquidity = Getliquidity(liquidity_tokens);\n  console.log('liquidity: ', liquidity);\n\n  const amount1Min = ethers.utils.parseUnits(String(amount1min), token1Decimals);\n  const amount2Min = ethers.utils.parseUnits(String(amount2min), token2Decimals);\n\n  const time = Math.floor(Date.now() / 1000) + 200000;\n  const deadline = ethers.BigNumber.from(time);\n\n  const wethAddress = await routerContract.WETH();\n  const pairAddress = await factory.getPair(address1, address2);\n  const pair = new Contract(pairAddress, PAIR.abi, signer);\n\n  await pair.approve(routerContract.address, liquidity);\n\n  console.log([\n    address1,\n    address2,\n    Number(liquidity),\n    Number(amount1Min),\n    Number(amount2Min),\n    account,\n    deadline,\n  ]);\n\n  if (address1 === wethAddress) {\n    // Eth + Token\n    await routerContract.removeLiquidityETH(\n      address2,\n      liquidity,\n      amount2Min,\n      amount1Min,\n      account,\n      deadline\n    );\n  } else if (address2 === wethAddress) {\n    // Token + Eth\n    await routerContract.removeLiquidityETH(\n      address1,\n      liquidity,\n      amount1Min,\n      amount2Min,\n      account,\n      deadline\n    );\n  } else {\n    // Token + Token\n    await routerContract.removeLiquidity(\n      address1,\n      address2,\n      liquidity,\n      amount1Min,\n      amount2Min,\n      account,\n      deadline\n    );\n  }\n}\n\nconst quote = (amount1, reserve1, reserve2) => {\n  const amount2 = amount1 * (reserve2 / reserve1);\n  return [amount2];\n};\n\n// Function used to get a quote of the liquidity addition\n//    `address1` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `address2` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `amountA_desired` - The prefered value of the first token that the user would like to deploy as liquidity\n//    `amountB_desired` - The prefered value of the second token that the user would like to deploy as liquidity\n//    `factory` - The current factory\n//    `signer` - The current signer\n\nasync function quoteMintLiquidity(\n  address1,\n  address2,\n  amountA,\n  amountB,\n  factory,\n  signer\n){\n  const MINIMUM_LIQUIDITY = 1000;\n  let _reserveA = 0;\n  let _reserveB = 0;\n  let totalSupply = 0;\n  [_reserveA, _reserveB, totalSupply] = await factory.getPair(address1, address2).then(async (pairAddress) => {\n    if (pairAddress !== '0x0000000000000000000000000000000000000000'){\n      const pair = new Contract(pairAddress, PAIR.abi, signer);\n\n      const reservesRaw = await fetchReserves(address1, address2, pair, signer); // Returns the reserves already formated as ethers\n      const reserveA = reservesRaw[0];\n      const reserveB = reservesRaw[1];\n    \n      const _totalSupply = await pair.totalSupply();\n      const totalSupply = Number(ethers.utils.formatEther(_totalSupply));\n      return [reserveA, reserveB, totalSupply]\n    } else {\n      return [0,0,0]\n    }\n  });\n\n  const token1 = new Contract(address1, ERC20.abi, signer);\n  const token2 = new Contract(address2, ERC20.abi, signer);\n\n  // Need to do all this decimals work to account for 0 decimal numbers\n\n  const token1Decimals = await getDecimals(token1);\n  const token2Decimals = await getDecimals(token2);\n\n  const valueA = amountA*(10**token1Decimals);\n  const valueB = amountB*(10**token2Decimals);\n\n  const reserveA = _reserveA*(10**token1Decimals);\n  const reserveB = _reserveB*(10**token2Decimals);\n\n  if (totalSupply == 0){\n    return Math.sqrt(((valueA * valueB)-MINIMUM_LIQUIDITY))*10**(-18);\n  };\n  \n  return (\n    Math.min(valueA*totalSupply/reserveA, valueB*totalSupply/reserveB)\n  );\n};\n\nexport async function quoteAddLiquidity(\n  address1,\n  address2,\n  amountADesired,\n  amountBDesired,\n  factory,\n  signer\n) {\n\n  const pairAddress = await factory.getPair(address1, address2);\n  const pair = new Contract(pairAddress, PAIR.abi, signer);\n\n  const reservesRaw = await fetchReserves(address1, address2, pair, signer); // Returns the reserves already formated as ethers\n  const reserveA = reservesRaw[0];\n  const reserveB = reservesRaw[1];\n\n  if (reserveA === 0 && reserveB === 0) {\n    const amountOut = await quoteMintLiquidity(\n      address1,\n      address2,\n      amountADesired,\n      amountBDesired,\n      factory,\n      signer);\n    return [\n      amountADesired,\n      amountBDesired,\n      amountOut.toPrecision(8),\n    ];\n  } else {\n    const amountBOptimal = quote(amountADesired, reserveA, reserveB);\n    if (amountBOptimal <= amountBDesired) {\n      const amountOut = await quoteMintLiquidity(\n        address1,\n        address2,\n        amountADesired,\n        amountBOptimal,\n        factory,\n        signer);\n      return [\n        amountADesired,\n        amountBOptimal,\n        amountOut.toPrecision(8),\n      ];\n    } else {\n      const amountAOptimal = quote(\n        amountBDesired,\n        reserveB,\n        reserveA\n      );\n      const amountOut = await quoteMintLiquidity(\n        address1,\n        address2,\n        amountAOptimal,\n        amountBDesired,\n        factory,\n        signer);\n      return [\n        amountAOptimal,\n        amountBDesired,\n        amountOut.toPrecision(8),\n      ];\n    }\n  }\n}\n\n// Function used to get a quote of the liquidity removal\n//    `address1` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `address2` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `liquidity` - The amount of liquidity tokens the user will burn to get their tokens back\n//    `factory` - The current factory\n//    `signer` - The current signer\n\nexport async function quoteRemoveLiquidity(\n  address1,\n  address2,\n  liquidity,\n  factory,\n  signer\n) {\n  const pairAddress = await factory.getPair(address1, address2);\n  console.log(\"pair address\", pairAddress);\n  const pair = new Contract(pairAddress, PAIR.abi, signer);\n\n  const reservesRaw = await fetchReserves(address1, address2, pair, signer); // Returns the reserves already formated as ethers\n  const reserveA = reservesRaw[0];\n  const reserveB = reservesRaw[1];\n\n  const feeOn =\n    (await factory.feeTo()) !== 0x0000000000000000000000000000000000000000;\n\n  const _kLast = await pair.kLast();\n  const kLast = Number(ethers.utils.formatEther(_kLast));\n\n  const _totalSupply = await pair.totalSupply();\n  let totalSupply = Number(ethers.utils.formatEther(_totalSupply));\n\n  if (feeOn && kLast > 0) {\n    const feeLiquidity =\n      (totalSupply * (Math.sqrt(reserveA * reserveB) - Math.sqrt(kLast))) /\n      (5 * Math.sqrt(reserveA * reserveB) + Math.sqrt(kLast));\n    totalSupply = totalSupply + feeLiquidity;\n  }\n\n  const Aout = (reserveA * liquidity) / totalSupply;\n  const Bout = (reserveB * liquidity) / totalSupply;\n\n  return [liquidity, Aout, Bout];\n}\n"]},"metadata":{},"sourceType":"module"}